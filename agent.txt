"""
Starter scaffold for the CS 294-264 HW1 ReAct agent.

Students must implement a minimal ReAct agent that:
- Maintains a message history list (role, content, timestamp, unique_id)
- Uses a textual function-call format (see ResponseParser) with rfind-based parsing
- Alternates Reasoning and Acting until calling the tool `finish`
- Supports tools: `run_bash_cmd`, `finish`

This file intentionally omits core implementations and replaces them with
clear specifications and TODOs.
"""

from typing import List, Callable, Dict, Any
import time

from response_parser import ResponseParser
from llm import LLM, OpenAIModel
import inspect

class ReactAgent:
    """
    Minimal ReAct agent that:
    - Maintains a message history list with unique ids
    - Builds the LLM context from the message list
    - Registers callable tools with auto-generated docstrings in the system prompt
    - Runs a Reason-Act loop until `finish` is called or MAX_STEPS is reached
    """

    def __init__(self, name: str, parser: ResponseParser, llm: LLM):
        self.name: str = name
        self.parser = parser
        self.llm = llm

        # Message list storage
        self.id_to_message: List[Dict[str, Any]] = []
        self.root_message_id: int = -1
        self.current_message_id: int = -1

        # Registered tools
        self.function_map: Dict[str, Callable] = {}

        # Set up the initial structure of the history
        # Create required root nodes and a user node (task)
        self.system_message_id = self.add_message("system", "You are a Smart ReAct agent.")
        self.user_message_id = self.add_message("user", "")
        # NOTE: mandatory finish function that terminates the agent
        self.add_functions([self.finish])

    # -------------------- MESSAGE LIST --------------------
    def add_message(self, role: str, content: str) -> int:
        """
        Create a new message and add it to the list.

        The message must include fields: role, content, timestamp, unique_id.
        
        TODO(student): Implement this function to add a message to the list
        """
        unique_id = len(self.id_to_message)
        message = {
            "role": role,
            "content": content,
            "timestamp": time.time(),
            "unique_id": unique_id
        }
        self.id_to_message.append(message)
        return unique_id

    def set_message_content(self, message_id: int, content: str) -> None:
        """
        Update message content by id.
        
        TODO(student): Implement this function to update a message's content
        """
        if message_id < 0 or message_id >= len(self.id_to_message):
            raise ValueError(f"Invalid message_id: {message_id}")
        self.id_to_message[message_id]["content"] = content

    def get_context(self) -> str:
        """
        Build the full LLM context from the message list.
        
        TODO(student): Implement this function to build the context from the message list
        """
        context_parts = []
        for message_id in range(len(self.id_to_message)):
            context_parts.append(self.message_id_to_context(message_id))
        return "".join(context_parts)

    # -------------------- REQUIRED TOOLS --------------------
    def add_functions(self, tools: List[Callable]):
        """
        Add callable tools to the agent's function map.

        The system prompt must include tool descriptions that cover:
        - The signature of each tool
        - The docstring of each tool
        
        TODO(student): Implement this function to register tools and build tool descriptions
        """
        for tool in tools:
            self.function_map[tool.__name__] = tool
        
        # Update the system message to include tool descriptions
        # The message_id_to_context method will automatically include tool descriptions
        # when building the system message context, so we don't need to update the content here
    def finish(self, result: str):
        """The agent must call this function with the final result when it has solved the given task. The function calls "git add -A and git diff --cached" to generate a patch and returns the patch as submission.

        Args: 
            result (str); the result generated by the agent

        Returns:
            The result passed as an argument.  The result is then returned by the agent's run method.
        """
        return result 

    # -------------------- MAIN LOOP --------------------
    def run(self, task: str, max_steps: int) -> str:
        """
        Run the agent's main ReAct loop:
        - Set the user prompt
        - Loop up to max_steps (<= 100):
            - Build context from the message list (with `message_id_to_context`)
            - Query the LLM
            - Parse a single function call at the end (see ResponseParser)
            - Execute the tool
            - Append tool result to the list
            - If `finish` is called, return the final result
            
        TODO(student): Implement the main ReAct loop
        """
        # Set the user task message
        self.set_message_content(self.user_message_id, task)
        
        # Main ReAct loop
        for step in range(max_steps):
            # Build messages for LLM from the message list
            messages = []
            for message_id in range(len(self.id_to_message)):
                message = self.id_to_message[message_id]
                if message["role"] == "system":
                    # For system message, build clean content with tool descriptions (no debug headers)
                    content = message["content"]
                    # Add tool descriptions
                    tool_descriptions = []
                    for tool in self.function_map.values():
                        signature = inspect.signature(tool)
                        docstring = inspect.getdoc(tool)
                        tool_description = f"Function: {tool.__name__}{signature}\n{docstring}\n"
                        tool_descriptions.append(tool_description)
                    
                    tool_descriptions_text = "\n".join(tool_descriptions)
                    content = (
                        f"{content}\n"
                        f"--- AVAILABLE TOOLS ---\n{tool_descriptions_text}\n\n"
                        f"--- RESPONSE FORMAT ---\n{self.parser.response_format}\n"
                    )
                else:
                    # For other messages, use the content directly
                    content = message["content"]
                
                messages.append({
                    "role": message["role"],
                    "content": content
                })
            
            # Query the LLM
            response_text = self.llm.generate(messages)
            
            # Add the assistant's response to message history
            assistant_message_id = self.add_message("assistant", response_text)
            
            # Parse the function call from the response
            try:
                parsed = self.parser.parse(response_text)
            except (ValueError, Exception) as e:
                # If parsing fails, inform the LLM and continue
                error_msg = f"Failed to parse function call from response: {str(e)}. Please ensure your response follows the required format with {self.parser.BEGIN_CALL} and {self.parser.END_CALL} markers."
                self.add_message("user", error_msg)
                continue
            
            # Get function name and arguments
            function_name = parsed["name"]
            arguments = parsed["arguments"]
            
            # Check if finish was called
            if function_name == "finish":
                result = arguments.get("result", "")
                # Add the finish result to message history
                self.add_message("user", f"finish returned: {result}")
                return result
            
            # Execute the tool
            if function_name not in self.function_map:
                error_msg = f"Unknown function: {function_name}"
                self.add_message("user", error_msg)
                continue
            
            try:
                tool = self.function_map[function_name]
                # Call the tool with the parsed arguments
                result = tool(**arguments)
                # Add the tool result to message history
                self.add_message("user", f"{function_name} returned: {result}")
            except Exception as e:
                error_msg = f"{function_name} raised an error: {str(e)}"
                self.add_message("user", error_msg)
        
        # If we've exhausted max_steps, return empty result
        return ""

    def message_id_to_context(self, message_id: int) -> str:
        """
        Helper function to convert a message id to a context string.
        """
        message = self.id_to_message[message_id]
        header = f'----------------------------\n|MESSAGE(role="{message["role"]}", id={message["unique_id"]})|\n'
        content = message["content"]
        if message["role"] == "system":
            tool_descriptions = []
            for tool in self.function_map.values():
                signature = inspect.signature(tool)
                docstring = inspect.getdoc(tool)
                tool_description = f"Function: {tool.__name__}{signature}\n{docstring}\n"
                tool_descriptions.append(tool_description)

            tool_descriptions = "\n".join(tool_descriptions)
            return (
                f"{header}{content}\n"
                f"--- AVAILABLE TOOLS ---\n{tool_descriptions}\n\n"
                f"--- RESPONSE FORMAT ---\n{self.parser.response_format}\n"
            )
        else:
            return f"{header}{content}\n"

def main():
    from envs import DumbEnvironment
    llm = OpenAIModel("----END_FUNCTION_CALL----", "gpt-4o-mini")
    parser = ResponseParser()

    env = DumbEnvironment()
    dumb_agent = ReactAgent("dumb-agent", parser, llm)
    dumb_agent.add_functions([env.run_bash_cmd])
    result = dumb_agent.run("Show the contents of all files in the current directory.", max_steps=10)
    print(result)

if __name__ == "__main__":
    # Optional: students can add their own quick manual test here.
    main()


"""
Starter scaffold for the CS 294-264 HW1 ReAct agent.

Students must implement a minimal ReAct agent that:
- Maintains a message history list (role, content, timestamp, unique_id)
- Uses a textual function-call format (see ResponseParser) with rfind-based parsing
- Alternates Reasoning and Acting until calling the tool `finish`
- Supports tools: `run_bash_cmd`, `finish`

This file intentionally omits core implementations and replaces them with
clear specifications and TODOs.
"""

from typing import List, Callable, Dict, Any
import time

from response_parser import ResponseParser
from llm import LLM, OpenAIModel
import inspect

class ReactAgent:
    """
    Minimal ReAct agent that:
    - Maintains a message history list with unique ids
    - Builds the LLM context from the message list
    - Registers callable tools with auto-generated docstrings in the system prompt
    - Runs a Reason-Act loop until `finish` is called or MAX_STEPS is reached
    """

    def __init__(self, name: str, parser: ResponseParser, llm: LLM):
        self.name: str = name
        self.parser = parser
        self.llm = llm

        # Message list storage
        self.id_to_message: List[Dict[str, Any]] = []
        self.root_message_id: int = -1
        self.current_message_id: int = -1

        # Registered tools
        self.function_map: Dict[str, Callable] = {}

        # Set up the initial structure of the history
        # Create required root nodes and a user node (task)
        self.system_message_id = self.add_message("system", "You are a Smart ReAct agent.")
        self.user_message_id = self.add_message("user", "")
        # NOTE: mandatory finish function that terminates the agent
        self.add_functions([self.finish])

    # -------------------- MESSAGE LIST --------------------
    def add_message(self, role: str, content: str) -> int:
        """
        Create a new message and add it to the list.

        The message must include fields: role, content, timestamp, unique_id.
        
        TODO(student): Implement this function to add a message to the list
        """
        raise NotImplementedError("add_message must be implemented by the student")

    def set_message_content(self, message_id: int, content: str) -> None:
        """
        Update message content by id.
        
        TODO(student): Implement this function to update a message's content
        """
        raise NotImplementedError("set_message_content must be implemented by the student")

    def get_context(self) -> str:
        """
        Build the full LLM context from the message list.
        
        TODO(student): Implement this function to build the context from the message list
        """
        raise NotImplementedError("get_context must be implemented by the student")

    # -------------------- REQUIRED TOOLS --------------------
    def add_functions(self, tools: List[Callable]):
        """
        Add callable tools to the agent's function map.

        The system prompt must include tool descriptions that cover:
        - The signature of each tool
        - The docstring of each tool
        
        TODO(student): Implement this function to register tools and build tool descriptions
        """
        raise NotImplementedError("add_functions must be implemented by the student")
    
    def finish(self, result: str):
        """The agent must call this function with the final result when it has solved the given task. The function calls "git add -A and git diff --cached" to generate a patch and returns the patch as submission.

        Args: 
            result (str); the result generated by the agent

        Returns:
            The result passed as an argument.  The result is then returned by the agent's run method.
        """
        return result 

    # -------------------- MAIN LOOP --------------------
    def run(self, task: str, max_steps: int) -> str:
        """
        Run the agent's main ReAct loop:
        - Set the user prompt
        - Loop up to max_steps (<= 100):
            - Build context from the message list (with `message_id_to_context`)
            - Query the LLM
            - Parse a single function call at the end (see ResponseParser)
            - Execute the tool
            - Append tool result to the list
            - If `finish` is called, return the final result
            
        TODO(student): Implement the main ReAct loop
        """
        # Set the user task message
        # self.set_message_content(self.user_message_id, task)
        
        # Main ReAct loop
        raise NotImplementedError("run method must be implemented by the student")

    def message_id_to_context(self, message_id: int) -> str:
        """
        Helper function to convert a message id to a context string.
        """
        message = self.id_to_message[message_id]
        header = f'----------------------------\n|MESSAGE(role="{message["role"]}", id={message["unique_id"]})|\n'
        content = message["content"]
        if message["role"] == "system":
            tool_descriptions = []
            for tool in self.function_map.values():
                signature = inspect.signature(tool)
                docstring = inspect.getdoc(tool)
                tool_description = f"Function: {tool.__name__}{signature}\n{docstring}\n"
                tool_descriptions.append(tool_description)

            tool_descriptions = "\n".join(tool_descriptions)
            return (
                f"{header}{content}\n"
                f"--- AVAILABLE TOOLS ---\n{tool_descriptions}\n\n"
                f"--- RESPONSE FORMAT ---\n{self.parser.response_format}\n"
            )
        else:
            return f"{header}{content}\n"

def main():
    from envs import DumbEnvironment
    llm = OpenAIModel("----END_FUNCTION_CALL----", "gpt-4o-mini")
    parser = ResponseParser()

    env = DumbEnvironment()
    dumb_agent = ReactAgent("dumb-agent", parser, llm)
    dumb_agent.add_functions([env.run_bash_cmd])
    result = dumb_agent.run("Show the contents of all files in the current directory.", max_steps=10)
    print(result)

if __name__ == "__main__":
    # Optional: students can add their own quick manual test here.
    main()
